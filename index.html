<!DOCTYPE html>
<html>
<head>
  <title>emacs.tv</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="apple-touch-icon" href="icon.png">
  <style>
    body, div, p, h3 {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      line-height: 1.5em;
      background-color: #ffffff;
      margin: 0 auto;
      max-width: 70ch;
      padding: 5px;
    }
    .item p {
      margin: 0;
      display: flex;
      flex-wrap: wrap;
    }
    .item {
      margin-bottom: 1em;
    }
    .tag {
      color: #2A9D8F;
      cursor: pointer;
    }
    .dismissible {
      padding: 0.3em 0.6em;
      border: 1px solid #777;
      border-radius: 5px;
      font-size: 0.8em;
      margin: 0 0.2em;
      cursor: pointer;
    }
    .x {
      color: #777;
    }
    .speakers {
      color: #777;
      font-size: 0.8em;
    }
    a, a:visited {
      text-decoration: none;
      color: #4183C4;
    }
    .item .date {
      font-size: 0.95em;
      color: #777;
    }
    video {
      width: 85%;
      display: block;
      margin: 0 auto;
    }
    @media (prefers-color-scheme: dark) {
      body, div, p, h3 {
        background-color: #121212;
        color: #E0E0E0;
      }
      .tag {
        color: #80CBC4;
      }
      .dismissible {
        border: 1px solid #555;
        color: #E0E0E0;
      }
      .x {
        color: #BDBDBD;
      }
      .speakers, .item .date {
        color: #BDBDBD;
      }
      a, a:visited {
        color: #9DDFFA;
      }
      select {
        background-color: transparent;
        color: #E0E0E0;
        border: 1px solid #555;
        padding: 0.3em;
        border-radius: 5px;
      }
      option {
        background-color: transparent;
        color: #E0E0E0;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script>
    document.addEventListener('DOMContentLoaded', async function () {
      store = app.makeStore();
      store.state.subscribe((state) => {
        const root = document.getElementById("root");
        if (!root) {
          return;
        }

        const { html, handlers } = app.render(state, store);
        root.innerHTML = html;

        handlers.forEach(({ nodeId, listenerName, handler }) => {
          const element = document.getElementById(nodeId);
          if (element) {
            element.addEventListener(listenerName, handler);
          }
        });
      });
     store.load();
    });
    var app = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // src/index.ts
  var index_exports = {};
  __export(index_exports, {
    OrgDocument: () => OrgDocument,
    OrgHeading: () => OrgHeading,
    OrgParser: () => OrgParser,
    StateStore: () => StateStore,
    ValueStore: () => ValueStore,
    ValueStream: () => ValueStream,
    makeState: () => makeState,
    makeStore: () => makeStore,
    render: () => render
  });
  function render(state, store) {
    let handlers = [];
    const randomPick = new RandomPickRenderer(store).render(state.orgDocument.headings);
    handlers = handlers.concat(randomPick.handlers);
    const tagPicker = new TagsPickerRenderer(store).render(state.orgDocument.headings);
    handlers = handlers.concat(tagPicker.handlers);
    const filterByTags = new FilterByTagsRenderer(store).render(state.filterByTags);
    handlers = handlers.concat(filterByTags.handlers);
    const filteredHeadings = state.orgDocument.headings.filter(
      (heading) => state.filterByTags.length === 0 || state.filterByTags.every(
        (filterTag) => heading.tags?.map((tag) => tag.toLowerCase()).includes(filterTag)
      )
    );
    const videoList = new VideoListRenderer(store).render(filteredHeadings);
    handlers = handlers.concat(videoList.handlers);
    let html = `
<h1>\u{1F9AC} emacs.tv</h1>
<br>
  ${randomPick.html}
<br>
<br>
<div>
  ${tagPicker.html} ${filterByTags.html}
</div>
<br>
${videoList.html}`;
    return {
      html: state.error ? state.error : html,
      handlers
    };
  }
  var RandomPickRenderer = class {
    constructor(store) {
      this.store = store;
    }
    render(headings) {
      let handlers = [];
      headings = headings.filter((heading) => heading.drawer?.MEDIA_URL);
      if (headings.length === 0) {
        return {
          handlers,
          html: "<div>No media available.</div>"
        };
      }
      const randomHeading = headings[Math.floor(Math.random() * headings.length)];
      return {
        handlers,
        html: `<video controls>
                <source src="${randomHeading.drawer.MEDIA_URL}" type="video/webm">
                Your browser does not support the video tag.
             </video>`
      };
    }
  };
  var TagsPickerRenderer = class {
    constructor(store) {
      this.store = store;
    }
    render(headings) {
      let handlers = [];
      return {
        handlers,
        html: `<select id="filter" name="options" onchange="store.addFilterTag(this.value)">
               <option value="">filter</option>
                 ${Array.from(new Set(headings.flatMap((heading) => heading.tags.map((tag) => tag.toLowerCase()) ?? []))).sort().map((tag) => `<option value="${tag}">${tag}</option>`).join("")}
             </select>`
      };
    }
  };
  var VideoListRenderer = class {
    constructor(store) {
      this.store = store;
    }
    render(headings) {
      const result = headings.reduce((acc, heading) => {
        const date = heading.drawer?.DATE ? new Date(heading.drawer.DATE).toLocaleDateString("en-US", {
          year: "numeric",
          month: "long",
          day: "numeric"
        }) : "";
        const title = heading.title || "Untitled";
        const tags = heading.tags?.sort()?.map((tag) => {
          tag = tag.toLowerCase();
          const tagId = `tag-${tag}-${randomUUID()}`;
          acc.handlers.push({
            nodeId: tagId,
            listenerName: "click",
            handler: () => this.store.addFilterTag(tag)
          });
          return `<span id="${tagId}" class="tag">#${tag}</span>&nbsp;`;
        }).join(" ") || "";
        const links = Object.keys(heading.drawer ?? {}).filter((key) => key.endsWith("_URL") && heading.drawer[key]?.trim()).map((key) => {
          return `<a href="${heading.drawer[key]}" target="_blank">${key.slice(0, -4).toLowerCase()}</a>`;
        }).join("&nbsp;\xB7&nbsp;");
        const speakers = heading.drawer?.SPEAKERS;
        acc.html += `
      <div class="item">
        <p class="date">${date}</p>
        <p><strong>${title}</strong></p>
        <p>${tags}</p>
${speakers ? `<p class="speakers">By ${speakers}</p>` : ""}
        <p>${links}</p>
      </div><br>`;
        return acc;
      }, { html: "", handlers: [] });
      return result;
    }
  };
  var FilterByTagsRenderer = class {
    constructor(store) {
      this.store = store;
    }
    render(tags) {
      let handlers = [];
      return {
        handlers,
        html: tags.map((tag) => {
          const tagId = `filter-${tag}-${randomUUID()}`;
          handlers.push({
            nodeId: tagId,
            listenerName: "click",
            handler: () => this.store.removeFilterTag(tag)
          });
          return `<span id="${tagId}" class="dismissible"><span class="tag">#${tag}</span>&nbsp;<span class="x">x</span></span>`;
        }).join(" ") || ""
      };
    }
  };
  var StateStore = class {
    constructor() {
      this.state = new ValueStream({
        filterByTags: [],
        orgDocument: new OrgDocument([])
      });
    }
    async load() {
      try {
        const response = await fetch("./videos.org");
        if (!response.ok) {
          console.error("Could not fetch org feed");
          this.state.mutate((state) => {
            state.orgDocument = new OrgDocument([]);
            return state;
          });
          return;
        }
        const text = await response.text();
        this.state.mutate((state) => {
          const orgDocument = OrgParser.parse(text);
          orgDocument.headings = orgDocument.headings.sort((a, b) => {
            const dateA = new Date(a.drawer?.DATE || 0);
            const dateB = new Date(b.drawer?.DATE || 0);
            return dateB.getTime() - dateA.getTime() || (!a.drawer?.DATE ? 1 : 0);
          });
          state.orgDocument = orgDocument;
          return state;
        });
      } catch (error) {
        console.error(error);
        this.state.mutate((state) => {
          state.error = error instanceof Error ? error.message : "Unknown error occurred";
          return state;
        });
      }
    }
    filterByTags(tagNames) {
      this.state.mutate((state) => {
        state.filterByTags = tagNames;
        return state;
      });
    }
    addFilterTag(tag) {
      this.state.mutate((state) => {
        if (state.filterByTags.includes(tag.trim())) {
          return state;
        }
        state.filterByTags.push(tag.trim());
        return state;
      });
    }
    removeFilterTag(tag) {
      this.state.mutate((state) => {
        state.filterByTags = state.filterByTags.filter((filterTag) => filterTag !== tag);
        return state;
      });
    }
    resetFilter() {
      this.state.mutate((state) => {
        state.filterByTags = [];
        return state;
      });
    }
  };
  var OrgDocument = class {
    constructor(headings) {
      this.headings = headings;
    }
  };
  var OrgHeading = class {
    constructor(title, tags, drawer) {
      this.title = title;
      this.tags = tags;
      this.drawer = drawer;
    }
  };
  var OrgParser = class {
    static parse(orgContent) {
      const lines = orgContent.split("\n");
      const headings = [];
      let currentHeading = null;
      for (let line of lines) {
        if (line.startsWith("* ")) {
          if (currentHeading) {
            headings.push(currentHeading);
          }
          const [rest, tagsPart] = line.split(/ +:/);
          const tags = tagsPart ? tagsPart.split(":").filter((tag) => tag.trim() !== "") : [];
          const title = rest.replace(/^\* /, "").trim();
          currentHeading = new OrgHeading(title, tags, {});
          continue;
        }
        if (line.startsWith(":") && currentHeading) {
          const match = line.match(/^:([^:]+):\s*(.*)$/);
          if (line === ":PROPERTIES:" || line === ":END:") {
            continue;
          }
          if (match) {
            const [, key, value] = match;
            currentHeading.drawer[key] = value.trim();
          }
          continue;
        }
      }
      if (currentHeading) {
        headings.push(currentHeading);
      }
      ;
      return new OrgDocument(headings);
    }
  };
  var ValueStore = class {
    constructor() {
      this.memoryStore = /* @__PURE__ */ new Map();
    }
    getString(key) {
      if (typeof window !== "undefined" && window.localStorage) {
        return localStorage.getItem(key);
      } else {
        return this.memoryStore.get(key) || null;
      }
    }
    setString(key, value) {
      if (typeof window !== "undefined" && window.localStorage) {
        localStorage.setItem(key, value);
      } else {
        this.memoryStore.set(key, value);
      }
    }
    getObject(key) {
      const value = this.getString(key);
      return value ? JSON.parse(value) : null;
    }
    setObject(key, value) {
      this.setString(key, JSON.stringify(value));
    }
  };
  var ValueStream = class {
    constructor(initialValue) {
      this.subscribers = /* @__PURE__ */ new Set();
      if (initialValue !== void 0) {
        this.currentValue = initialValue;
      }
    }
    subscribe(listener) {
      this.subscribers.add(listener);
      if (this.currentValue !== void 0) {
        this.emit(this.currentValue);
      }
      return () => this.subscribers.delete(listener);
    }
    emit(value) {
      this.currentValue = value;
      this.subscribers.forEach((listener) => listener(value));
    }
    clear() {
      this.subscribers.clear();
    }
    mutate(mutator) {
      if (this.currentValue !== void 0) {
        const newValue = typeof this.currentValue === "object" && this.currentValue !== null ? structuredClone(this.currentValue) : this.currentValue;
        this.currentValue = mutator(newValue);
        this.emit(this.currentValue);
      }
    }
  };
  function makeStore() {
    const store = new StateStore();
    store.state.mutate((state) => {
      state = makeState();
      return state;
    });
    return store;
  }
  function makeState() {
    return {
      filterByTags: [],
      orgDocument: new OrgDocument([])
    };
  }
  function randomUUID() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
  return __toCommonJS(index_exports);
})();

  </script>
</body>
</html>
