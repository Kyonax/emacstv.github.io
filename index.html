<!DOCTYPE html>
<html>
<head>
  <title>emacs.tv</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="apple-touch-icon" href="icon.png">
  <style>
    body, div, p, h3 {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      line-height: 1.5em;
    }
    .item p {
      margin: 0;
      display: flex;
      flex-wrap: wrap;
    }
    .item {
      margin-bottom: 1em;
    }
    .tag {
      color: #2A9D8F;
      cursor: pointer;
    }
    .dismissible {
      padding: 0.3em 0.6em;
      border: 1px solid #000;
      border-style: dotted;
      border-radius: 5px;
      font-size: 0.8em;
      margin: 0 0.2em;
      cursor: pointer;
    }
    .speakers {
      color: #777;
      font-size: 0.8em;
    }
    a, a:visited {
      text-decoration: none;
      color: #4183C4;
    }
    .item .date {
      font-size: 0.95em;
      color: #777;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script>
    document.addEventListener('DOMContentLoaded', async function () {
      store = app.makeStore();
      store.state.subscribe((state) => {
        const root = document.getElementById("root");
        if (!root) {
          return;
        }

        const { html, handlers } = app.render(state, store);
        root.innerHTML = html;

        handlers.forEach(({ nodeId, listenerName, handler }) => {
          const element = document.getElementById(nodeId);
          if (element) {
            element.addEventListener(listenerName, handler);
          }
        });
      });
     store.load();
    });
    var app = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // src/index.ts
  var index_exports = {};
  __export(index_exports, {
    OrgDocument: () => OrgDocument,
    OrgHeading: () => OrgHeading,
    OrgParser: () => OrgParser,
    StateStore: () => StateStore,
    ValueStore: () => ValueStore,
    ValueStream: () => ValueStream,
    makeState: () => makeState,
    makeStore: () => makeStore,
    render: () => render
  });
  function render(state, store) {
    let handlers = [];
    let idCounter = 1;
    const filterByTags = state.filterByTags.map((tag) => {
      const tagId = `filter-${tag}-${idCounter}`;
      idCounter += 1;
      handlers.push({ nodeId: tagId, listenerName: "click", handler: () => store.removeFilterTag(tag) });
      return `<span id="${tagId}" class="tag dismissible">#${tag} <strong>x</strong></span>`;
    }).join(" ") || "";
    let html = `
<h1>\u{1F9AC} emacs.tv</h1>
<div>
 <select id="filter" name="options" onchange="store.addFilterTag(this.value)">
  <option value="">tag filter</option>
  ${Array.from(new Set(state.orgDocument.headings.flatMap((heading) => heading.tags.map((tag) => tag.toLowerCase()) ?? []))).sort().map((tag) => `<option value="${tag}">${tag}</option>`).join("")}
 </select> ${filterByTags}
</div>
<br>
  `;
    handlers.push({ nodeId: "filter", listenerName: "onchange", handler: (tag) => store.removeFilterTag(tag) });
    state.orgDocument.headings.filter((heading) => {
      if (state.filterByTags.length === 0) {
        return true;
      }
      return state.filterByTags.every((filterTag) => heading.tags.map((tag) => tag.toLowerCase()).includes(filterTag));
    }).forEach((heading) => {
      const date = heading.drawer?.DATE ? new Date(heading.drawer.DATE).toLocaleDateString("en-US", { year: "numeric", month: "long", day: "numeric" }) : "";
      const title = heading.title || "Untitled";
      const tags = heading.tags?.sort()?.map((tag) => {
        tag = tag.toLowerCase();
        const tagId = `tag-${tag}-${idCounter}`;
        idCounter += 1;
        handlers.push({ nodeId: tagId, listenerName: "click", handler: () => store.addFilterTag(tag) });
        return `<span id="${tagId}" class="tag">#${tag}</span>&nbsp;`;
      }).join(" ") || "";
      const links = Object.keys(heading.drawer ?? {}).filter((key) => key.endsWith("_URL")).map((key) => {
        return `<a href="${heading.drawer[key]}" target="_blank">${key.slice(0, -4).toLowerCase()}</a>`;
      }).join("&nbsp;\xB7&nbsp;");
      const speakers = heading.drawer?.SPEAKERS;
      html += `
      <div class="item">
        <p class="date">${date}</p>
        <p><strong>${title}</strong></p>
        <p>${tags}</p>
        <p class="speakers">By ${speakers}</p>
        <p>${links}</p>
      </div><br>`;
    });
    return {
      html: state.error ? state.error : html,
      handlers
    };
  }
  var StateStore = class {
    constructor() {
      this.state = new ValueStream({
        filterByTags: [],
        orgDocument: new OrgDocument([])
      });
    }
    async load() {
      try {
        const response = await fetch("./index.org");
        if (!response.ok) {
          console.error("Could not fetch org feed");
          this.state.mutate((state) => {
            state.orgDocument = new OrgDocument([]);
            return state;
          });
          return;
        }
        const text = await response.text();
        this.state.mutate((state) => {
          const orgDocument = OrgParser.parse(text);
          orgDocument.headings = orgDocument.headings.sort((a, b) => {
            const dateA = new Date(a.drawer?.DATE || 0);
            const dateB = new Date(b.drawer?.DATE || 0);
            return dateB.getTime() - dateA.getTime() || (!a.drawer?.DATE ? 1 : 0);
          });
          state.orgDocument = orgDocument;
          return state;
        });
      } catch (error) {
        console.error(error);
        this.state.mutate((state) => {
          state.error = error instanceof Error ? error.message : "Unknown error occurred";
          return state;
        });
      }
    }
    filterByTags(tagNames) {
      this.state.mutate((state) => {
        state.filterByTags = tagNames;
        return state;
      });
    }
    addFilterTag(tag) {
      this.state.mutate((state) => {
        if (state.filterByTags.includes(tag.trim())) {
          return state;
        }
        state.filterByTags.push(tag.trim());
        return state;
      });
    }
    removeFilterTag(tag) {
      this.state.mutate((state) => {
        state.filterByTags = state.filterByTags.filter((filterTag) => filterTag !== tag);
        return state;
      });
    }
    resetFilter() {
      this.state.mutate((state) => {
        state.filterByTags = [];
        return state;
      });
    }
  };
  var OrgDocument = class {
    constructor(headings) {
      this.headings = headings;
    }
  };
  var OrgHeading = class {
    constructor(title, tags, drawer) {
      this.title = title;
      this.tags = tags;
      this.drawer = drawer;
    }
  };
  var OrgParser = class {
    static parse(orgContent) {
      const lines = orgContent.split("\n");
      const headings = [];
      let currentHeading = null;
      for (let line of lines) {
        if (line.startsWith("* ")) {
          if (currentHeading) {
            headings.push(currentHeading);
          }
          const [rest, tagsPart] = line.split(/ +:/);
          const tags = tagsPart ? tagsPart.split(":").filter((tag) => tag.trim() !== "") : [];
          const title = rest.replace(/^\* /, "").trim();
          currentHeading = new OrgHeading(title, tags, {});
          continue;
        }
        if (line.startsWith(":") && currentHeading) {
          const match = line.match(/^:([^:]+):\s*(.*)$/);
          if (line === ":PROPERTIES:" || line === ":END:") {
            continue;
          }
          if (match) {
            const [, key, value] = match;
            currentHeading.drawer[key] = value.trim();
          }
          continue;
        }
      }
      if (currentHeading) {
        headings.push(currentHeading);
      }
      ;
      return new OrgDocument(headings);
    }
  };
  var ValueStore = class {
    constructor() {
      this.memoryStore = /* @__PURE__ */ new Map();
    }
    getString(key) {
      if (typeof window !== "undefined" && window.localStorage) {
        return localStorage.getItem(key);
      } else {
        return this.memoryStore.get(key) || null;
      }
    }
    setString(key, value) {
      if (typeof window !== "undefined" && window.localStorage) {
        localStorage.setItem(key, value);
      } else {
        this.memoryStore.set(key, value);
      }
    }
    getObject(key) {
      const value = this.getString(key);
      return value ? JSON.parse(value) : null;
    }
    setObject(key, value) {
      this.setString(key, JSON.stringify(value));
    }
  };
  var ValueStream = class {
    constructor(initialValue) {
      this.subscribers = /* @__PURE__ */ new Set();
      if (initialValue !== void 0) {
        this.currentValue = initialValue;
      }
    }
    subscribe(listener) {
      this.subscribers.add(listener);
      if (this.currentValue !== void 0) {
        this.emit(this.currentValue);
      }
      return () => this.subscribers.delete(listener);
    }
    emit(value) {
      this.currentValue = value;
      this.subscribers.forEach((listener) => listener(value));
    }
    clear() {
      this.subscribers.clear();
    }
    mutate(mutator) {
      if (this.currentValue !== void 0) {
        const newValue = typeof this.currentValue === "object" && this.currentValue !== null ? structuredClone(this.currentValue) : this.currentValue;
        this.currentValue = mutator(newValue);
        this.emit(this.currentValue);
      }
    }
  };
  function makeStore() {
    const store = new StateStore();
    store.state.mutate((state) => {
      state = makeState();
      return state;
    });
    return store;
  }
  function makeState() {
    return {
      filterByTags: [],
      orgDocument: new OrgDocument([])
    };
  }
  return __toCommonJS(index_exports);
})();

  </script>
</body>
</html>